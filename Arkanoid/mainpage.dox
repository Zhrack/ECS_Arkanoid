/*! \mainpage Project Overview
 *
 * \section intro_sec Introduction
 *
 * Hi,
 * the following is an overview of the technical assessment.
 *
 * I took the liberty of generating this documentation using Doxygen, to enable detailed explanation of choices throughout the code, in case they become a necessity.
 * This page should be sufficient for a quick explanation though. 
 * 
 *
 * \section setup_sec Project setup
 *
 * The project is a VS2017 solution. The only dependencies are the STL library, the SFML library for graphics, windowing, audio and inputs, Boost Property Tree and FileSystem to parse the JSON configuration file.
 * The dependencies are bundled with the project.
 *
 * \section overview_sec Overview
 *
 * Since the stated objective of the test is to measure my software design and gameplay programming abilities, I went for a, for me new, game architecture.
 * The code has all been made from scratch, without code reuse of older projects, since I didn't feel they reached a high enough code cleaness.
 * The game employs an Entity-Component architecture for all gameplay actors. This was my first time approaching this design and it has been an interesting experience.
 * Traditionally I always went for classic OOP architectures, which didn't cut it for the flexible approach in the game objects I wanted, given the limited amount of time at my disposal.
 * So in the end I went for an ECS architecture. I was inspired mainly by the Unity engine and a few articles read over the years on the internet.
 * 
 * \subsection subsec1 High level classes
 *
 * Starting with a top-down view, the game is structured as a Finite State Machine, the World class itself. It manages two states: MenuState and GameState.
 * The MenuState manages the initial starting screen and it is a fairly badic game loop.
 * The GameState instead is where the real meat is.
 * The ECS architecture uses it as a central hub for informations. 
 * In fact, I chose a variant of the classic ECS architecture, since, to better use data locality and the cache memory, all Components are stored in contiguous std::vectors, grouped by component type. The data structure is managed by GameState.
 * There is no "Entity" class, but it has been reduced to a single integer ID. This ID is the only member that connects components to form a single game actor and every component has one.
 * The "System" classes has been absorbed into the Components classes, so that, inspired by Unity, there are components of mainly data and components of mainly logic.
 * This way there are relatively few concepts and classes to keep track of and during development of Arkanoid, it has revealed a choice that gives flexibility in the definition of the various game actors.
 * 
 * Components have various ways to communicate and retrieve data:
 *	- through the GameState class itself, using the getComponent function
 *	- through the MessageHandler class, from which derives BaseComponent (the base class of all components)
 *	- through the GameState class again, as a central dispatcher of messages, for cases when a a components wants to send messages to groups of components
 * 
 * The MessageHandler class gives the capability to components to send and receive messages. 
 * Messages are usually processed at the beginning of the receiver's update step, this way it is effectively an event loop ready for a multithreaded environment with only minor modifications (lock mechanisms for shared resources, such as the message queue).
 * Messages can also be processed immediately, or after a delayed time.
 * This way the architecture can work as a Command pattern or an Event Loop pattern, giving a good flexibility.
 * 
 * The BaseComponent class inherits from MessageHandler, stores the EntityID, the EntityType (an enumerator that works as a simple tagging system for components) and few other variabiles.
 * 
 * From here, all components implements different functionalities. The TransformComponent is the only component always added to an entity, giving a transform matrix to the component.
 * Entities and Components creation, retrieval and management is done in the GameState class.
 * The addComponent function is a variadic template function, giving flexibility of using a common access point for component creation but the possibility of having components with different constructors paramenters then what is needed by the BaseComponent class.
 * Other templates in functions are used mainly to return a dynamically down-casted pointer to components.
 *
 * The GameState class also employs a lazy removal system for components. In fact a dirty flag is used to remove zombie components at the end of the update loop, simplifying removal management.
 * 
 * Other classes are:
 * 
 * The CollionDetector class manages all "physics" calculations for the game, providing collision detection and response for components using the ColliderComponents classes's data, simple collision detection algorithms (AABBvsCircle and the likes) and uses messages to signal callbacks inside colliders.
 * These callbacks are std::function objects that encapsulate functions of other components of (usually) the same entity. This way the response behavior for collision is personalized to the needs of more "game logic"-focused components.
 *
 * The ServiceLocator class acts as a "phone book" to find services. At the moment, it provides the AudioService and the TextureService, to access Audio functionalities and to get texture references, respectively.
 *
 *
 * All components types are mapped by an enumerator ComponentList, which automatically registers to GameState at the beginning of the game.
 * 
 * Game configuration data is managed using a JSON file, which is read and stored inside a Boost Property Tree's ptree object and retrieved at runtime from this data structure.
 * The high score of the game is saved on the file.
 *
 *
 * \subsection subsec2 The Game 
 *
 * Initially I planned on having all original power ups and aliens, plus the possibility to select different pre-made levels (I was thinking on building them using Tiled and importing them).
 * On top of this, I had thought about a couple possible special bricks and power ups, mostly intended as jokes about characters of Divinity: Original Sin.
 * 
 * In the end I ran out of time, since I couldn't dedicate as much time as I tought. 
 * Of the original power ups, I managed to implement the Sticky (yellow sphere) and the Disruption one (green sphere), plus I implemented one of the original power ups I wanted, the Bomber one (you will recognize it).
 * On the brick side, there are 3 types: 1-hit normal, 1-hit with double score and 2-hit bricks.
 *
 * Sound effects have been done using Bfxr, meanwhile the musics are Creative Commons ones found online.
 *
 *
 * Edit after more work: Added the Bomber power up.
 *
 * \subsection subsec3 Problems during the development
 *
 * My main problem has been time. I worked on it during the evenings and in fact I didn't manage to insert as many features as I wanted to have a polished game. 
 * At the moment the main lack is graphics, but also a variety of power ups and bricks. During the incoming weekend I plan on working on it more, to polish it.
 * On the software architecture side, there is room for improvement on the GameState class, as I think it became too large, unfortunately I didn't have time for a proper refactoring.
 * For example the game resources (sounds, textures) should be managed outside the GameState class. 
 * Also, a couple of bugs persists on the collisions side.
 *
 * Edit after more work: Sounds and textures are now implemented as services to other classes, using the Service Locator pattern.
 *
 *
 * \subsection subsec4 Conclusion
 *
 * Thanks for this experience. This was my first time implementing such an architecture and I must say that it has been a very funny project. Also, it seems to work! :)
 * I hope this small guide has been useful.
 *
 * Thanks for reading this and have a good day!
 *
 * Davide Marcoccio
 *
 */